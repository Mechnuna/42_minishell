В процессе работы над проектом незначительно изменялся subject. Вы можете выбрать редакцию.

Актуальная версия: `2` от 15.03.2022

<details>
	<summary> Первая версия subject. 12.12.2021 </summary>

# Minishell #

Такой же красивый как Shell

Резюме: цель этого проекта - создать простую оболочку. Да, свой маленький bash или zsh. Вы узнаете много нового о процессах и файловых дескрипторах.

# Содержание #

1. [Введение](#Введение)
2. [Общие инструкции](#Общие-инструкции)
3. [Обязательная часть](#Обязательная-часть)
4. [Бонусная часть](#Бонусная-часть)

# Глава I #

## Введение ##

Существование оболочек связано с самим существованием ИТ. В то время все кодировщики были согласны с тем, что общение с компьютером с использованием бинарных переключателей 1/0 серьезно раздражало. Было вполне логично, что им пришла в голову идея общаться с компьютером, используя интерактивные строки команд на языке, который немного близок к английскому.

С Minishell вы сможете путешествовать во времени и возвращаться к проблемам, с которыми люди сталкивались, когда Windows еще не существовало.

# Глава II #


## Общие инструкции ##

* Ваш проект должен быть написан в соответствии с Нормой. Если у вас есть бонусные файлы / функции, они включаются в проверку нормы, и вы получите 0, если внутри есть ошибка нормы;
* Ваши функции не должны завершаться неожиданно (segmentation fault, bus error, double, free и т.д.), За исключением неопределенного поведения. Если это произойдет, ваш проект будет считаться нефункциональным и во время оценки получит 0 баллов;
* При необходимости, все пространство памяти, выделенное кучей, должно быть освобождено должным образом. Утечки недопустимы.
* Если subject требует этого, вы должны отправить Makefile, который скомпилирует ваши исходные файлы для требуемого вывода с флагами -Wall, -Wextra и -Werror, и ваш Makefile не должен повторно связываться;
* Ваш Makefile должен содержать как минимум правила $ (NAME), all, clean, fclean и re;
* Чтобы превратить бонусы в свой проект, вы должны включить бонус правила в свой Makefile, который добавит все различные заголовки, библиотеки или функции, запрещенные в основной части проекта. Бонусы должны быть в другом файле _bonus. {C / h}. Оценка обязательной и бонусной части проводится отдельно;
* Если ваш проект позволяет вам использовать ваш libft, вы должны скопировать его исходный код и связанный с ним Makefile в папку libft с соответствующим Makefile. Makefile вашего проекта должен скомпилировать библиотеку, используя свой Makefile, а затем скомпилировать проект;
* Мы рекомендуем вам создать тестовые программы для своего проекта, даже если эту работу не нужно будет отправлять и оценивать. Это даст вам возможность легко проверить свою работу и работу коллег. Вы найдете эти тесты особенно полезными во время защиты. Действительно, во время защиты вы можете использовать свои тесты и / или тесты партнера, которого вы оцениваете;
* Отправьте свою работу в назначенный репозиторий git. Оцениваться будет только работа в репозитории git. Если DeepThreadt назначен для оценки вашей работы, это будет сделано после ваших оценок коллег. Если во время оценивания Deep Threatt в каком-либо разделе вашей работы произойдет ошибка, оценка будет остановлена.

# Глава III #

## Обязательная часть ##

Название программы  | minishell
:------------------:|:---------------
Файлы для сдачи     |
Makefile            | да
Параметры			|
Разрешенные внешние функции     |readline, rl_clear_history, rl_on_new_line, rl_replace_line, rl_redisplay, add_history, printf, malloc, free, write, access, open, read, close, fork, wait, waitpid, wait3, wait4, signal, sigaction, kill, exit, getcwd, chdir, stat, lstat, fstat, unlink, execve, dup, dup2, pipe, opendir, readdir, closedir, strerror, perror, isatty, ttyname, ttyslot, ioctl, getenv, tcsetattr, tcgetattr, tgetent, tgetflag, tgetnum, tgetstr, tgoto, tputs
Использование libft | Разрешено
Описание            | Напишите оболочку

Ваша оболочка должна:
* Не интерпретировать незакрытые кавычки или неуказанные специальные символы, такие как `\` или `;`
* Использовать не более одной глобальной переменной. Подумайте и будьте готовы объяснить, почему вы делаете именно так;
* Показывать подсказку при ожидании новой команды;
* Иметь рабочую историю;
* Находить и запускать нужный исполняемый файл (на основе переменной `PATH` или с помощью относительного или абсолютного пути);
* Он должен реализовывать встроенные функции:
	* echo с параметром -n
	* cd только с относительным или абсолютным путем
	* pwd без параметров
	* export без параметров
	* unset без опций
	* env без опций и аргументов
	* exit без опций
* `’` Запрещает любую интерпретацию последовательности символов;
* `"` запрещает любую интерпретацию последовательности символов, кроме символа `$`;
* Перенаправления:
	* `<` должен перенаправлять ввод
	* `>` должен перенаправлять вывод
	* `<<` считывает ввод из текущего источника, пока не появится строка, содержащая только разделитель. Н е нужно обновлять историю!
	* `>>` должен перенаправлять вывод с режимом добавления
* Pipes `|` Вывод каждой команды в пайплайне соединяется через `pipe` с входом следующей команды
* Переменные среды (`$`, за которыми следуют символы) должны расшириться до своих значений
* `$?` должен расшириться до статуса завершения последнего выполненного пайплайна переднего плана
* `ctrl-C`, `ctrl-D`, `ctrl-\` должны работать как в `bash`
* В интерактивном режиме:
	* `ctrl-C` печатает новое приглашение на новой строке
	* `ctrl-D` выход из оболочки
	* `ctrl-\` ничего не делать

> Функция readline может вызвать некоторую утечку, которую не нужно исправлять
>
> Но будьте осторожны, ваш собственный код не должен давать утечек.
>
> Вам стоит ограничиться описанием темы.
>
> Не требуется ничего, о чем не спрашивали.
>
> По каждому пункту, если у вас есть какие-либо сомнения, используйте ссылку на [bash](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/ "Ссылка на мануал по bash") в качестве справочника.

# Глава IV #

## Бонусная часть ##

* Если Обязательная часть не идеальна, даже не думай о бонусах

* &&, || с круглыми скобками для обозначения приоритетов

* подстановочный знак * должен работать для текущего рабочего каталога

</details>

<details>
	<summary> Вторая версия subject. 15.03.2022 </summary>

# Minishell #

Такой же красивый как Shell

Резюме: цель этого проекта - создать простую оболочку. Да, свой маленький bash или zsh. Вы узнаете много нового о процессах и файловых дескрипторах.

# Содержание #

1. [Введение](#Введение)
2. [Общие инструкции](#Общие-инструкции)
3. [Обязательная часть](#Обязательная-часть)
4. [Бонусная часть](#Бонусная-часть)
5. [Представление и экспертная оценка](#Представление-и-экспертная-оценка)

# Глава I #

## Введение ##

Существование оболочек связано с самим существованием ИТ. В то время все кодировщики были согласны с тем, что общение с компьютером с использованием бинарных переключателей 1/0 серьезно раздражало. Было вполне логично, что им пришла в голову идея общаться с компьютером, используя интерактивные строки команд на языке, который немного близок к английскому.

Благодаря Minishell вы сможете путешествовать во времени и возвращаться к проблемам, с которыми люди сталкивались, когда не существовало Windows.

# Глава II #


## Общие инструкции ##

* Ваш проект должен быть написан на C;
* Ваш проект должен быть написан в соответствии с Нормой. Если у вас есть бонусные файлы / функции, они включаются в проверку нормы, и вы получите 0, если внутри есть ошибка нормы;
* Ваши функции не должны завершаться неожиданно (segmentation fault, bus error, double, free и т.д.), За исключением неопределенного поведения. Если это произойдет, ваш проект будет считаться нефункциональным и во время оценки получит 0 баллов;
* При необходимости, все пространство памяти, выделенное кучей, должно быть освобождено должным образом. Утечки недопустимы.
* Если subject требует этого, вы должны отправить Makefile, который скомпилирует ваши исходные файлы для требуемого вывода с флагами -Wall, -Wextra и -Werror, и ваш Makefile не должен повторно связываться;
* Ваш Makefile должен содержать как минимум правила $ (NAME), all, clean, fclean и re;
* Чтобы превратить бонусы в свой проект, вы должны включить бонус правила в свой Makefile, который добавит все различные заголовки, библиотеки или функции, запрещенные в основной части проекта. Бонусы должны быть в другом файле _bonus. {C / h}. Оценка обязательной и бонусной части проводится отдельно;
* Если ваш проект позволяет вам использовать ваш libft, вы должны скопировать его исходный код и связанный с ним Makefile в папку libft с соответствующим Makefile. Makefile вашего проекта должен скомпилировать библиотеку, используя свой Makefile, а затем скомпилировать проект;
* Мы рекомендуем вам создать тестовые программы для своего проекта, даже если эту работу не нужно будет отправлять и оценивать. Это даст вам возможность легко проверить свою работу и работу коллег. Вы найдете эти тесты особенно полезными во время защиты. Действительно, во время защиты вы можете использовать свои тесты и / или тесты партнера, которого вы оцениваете;
* Отправьте свою работу в назначенный репозиторий git. Оцениваться будет только работа в репозитории git. Если DeepThreadt назначен для оценки вашей работы, это будет сделано после ваших оценок коллег. Если во время оценивания Deep Threatt в каком-либо разделе вашей работы произойдет ошибка, оценка будет остановлена.

# Глава III #

## Обязательная часть ##

Название программы  | minishell
:------------------:|:---------------
Файлы для сдачи     | Makefile, *.h, *.c
Makefile            | NAME, all, clean, fclean, re
Параметры			|
Разрешенные внешние функции     | readline, rl_clear_history, rl_on_new_line, rl_replace_line, rl_redisplay, add_history, printf, malloc, free, write, access, open, read, close, fork, wait, waitpid, wait3, wait4, signal, sigaction, sigemptyset, sigaddset, kill, exit, getcwd, chdir, stat, lstat, fstat, unlink, execve, dup, dup2, pipe, opendir, readdir, closedir, strerror, perror, isatty, ttyname, ttyslot, ioctl, getenv, tcsetattr, tcgetattr, tgetent, tgetflag, tgetnum, tgetstr, tgoto, tputs
Использование libft | Разрешено
Описание            | Напишите оболочку

Ваша оболочка должна:
* Отображать приглашение при ожидании новой команды;
* Иметь рабочую историю;
* Находить и запускать нужный исполняемый файл (на основе переменной `PATH` или с помощью относительного или абсолютного пути);
* Использовать не более одной глобальной переменной. Подумайте и будьте готовы объяснить, почему вы делаете именно так;
* Не интерпретировать незакрытые кавычки или специальные символы, которые не требует subject, такие как `\` или `;`
* `’` Запрещает любую интерпретацию последовательности символов;
* `"` запрещает любую интерпретацию последовательности символов, кроме символа `$`;
* Перенаправления:
	* `<` должен перенаправлять ввод
	* `>` должен перенаправлять вывод
	* `<<` считывает ввод из текущего источника, пока не появится строка, содержащая только разделитель. Н е нужно обновлять историю!
	* `>>` должен перенаправлять вывод с режимом добавления
* Pipes `|` Вывод каждой команды в пайплайне соединяется через `pipe` с входом следующей команды
* Переменные среды (`$`, за которыми следуют символы) должны расшириться до своих значений
* `$?` должен расшириться до статуса завершения последнего выполненного пайплайна переднего плана
* `ctrl-C`, `ctrl-D`, `ctrl-\` должны работать как в `bash`
* В интерактивном режиме:
	* `ctrl-C` печатает новое приглашение на новой строке
	* `ctrl-D` выход из оболочки
	* `ctrl-\` ничего не делать
* Он должен реализовывать встроенные функции:
	* echo с опцией -n
	* cd только с относительным или абсолютным путем
	* pwd без опций
	* export без опций
	* unset без опций
	* env без опций и аргументов
	* exit без опций

> Функция readline может вызвать некоторую утечку, которую не нужно исправлять
>
> Но будьте осторожны, ваш собственный код не должен давать утечек.
>
> Вам стоит ограничиться описанием темы.
>
> Не требуется ничего, о чем не спрашивали.
>
> По каждому пункту, если у вас есть какие-либо сомнения, используйте ссылку на [bash](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/ "Ссылка на мануал по bash") в качестве справочника.

# Глава IV #

## Бонусная часть ##

* Если Обязательная часть не идеальна, даже не думай о бонусах

* &&, || с круглыми скобками для обозначения приоритетов

* подстановочный знак * должен работать для текущего рабочего каталога

> Бонусная часть будет оцениваться только в том случае, если обязательная часть будет ИДЕАЛЬНОЙ. Идеальный означает, что обязательная часть была полностью выполнена и работает без сбоев. Если вы не выполнили ВСЕ обязательные требования, ваша бонусная часть вообще не будет оцениваться.

# Глава V #

## Представление и экспертная оценка ##

Сдайте задание в своем репозитории Git, как обычно. Во время защиты будет оцениваться только работа внутри вашего репозитория. Не стесняйтесь дважды проверять имена ваших файлов, чтобы убедиться, что они верны.

</details>
